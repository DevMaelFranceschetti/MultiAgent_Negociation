import numpy as np

def replaceAlloc(allocation, v, t):
    """ Compute the new allocation with task t asigned to vehicle v

    Parameters :
        allocation : List(int) the list of tasks allocades to each vehicle (in order)
        v : int, the vehicle id
        t : int, the task id

    Returns :
        List(int), the new allocation

    """
    return list(allocation[:v])+[t]+list(allocation[v+1:])

def getUtilityShape(nb_vehicles, nb_tasks):
    """ Compute the shape for this settings

    Parameters :
        nb_vehicles : int, the number of vehicles
        nb_tasks : int, the number of tasks

    Returns :
        a tuple containing the shape (tasks^vehicles * vehicles),
        that is the shape for the utility matrix.

    """
    list_dim = [nb_tasks]*nb_vehicles +[nb_vehicles]# matrix of shape tasks^vehicles * vehicles
    return tuple(list_dim)


def computeFrequency(proposals, tasks):
    """ Compute the empirical frequency of each proposal

    Parameters :
        proposals : List(int), the allocation proposed
        tasks : List(int) the list of task ids

    Returns :
        List(float), the empirical frequency of each proposal

    """
    return [np.count_nonzero(np.array(proposals) == t)/len(proposals) for t in range(len(tasks))]



def computePartialFrequencyMatrix(utilities, frequencies, vehicles, tasks, v):
    """
        Compute the expected utility for vehicle v foreach task, considering for each
        other vehicle a random allocation choice with probability equal to empirical frequency observed

    """
    temp_vehicles = vehicles[:v] + vehicles[v+1:] # create a list of index without vehicle v
    temp_alloc = np.zeros([len(tasks)]*(len(vehicles)-1)) # create a 0 array of shape (vehicles-1)^task
    allAlloc = [x for x,_ in np.ndenumerate(temp_alloc)] # enumerate all possible allocations for these vehicles
    expectations = []
    for t in range(len(tasks)):
        expected = 0
        for alloc in allAlloc : # for each possible allocation for vehicles without v
            # compute proba for these vehicles to do this allocation :
            proba = np.prod([frequencies[temp_vehicles[v]][alloc[v]] for v in range(len(temp_vehicles))])
            # recreating full allocation with v :
            index = [0]*len(vehicles)
            for i in range(len(temp_vehicles)) :
                index[temp_vehicles[i]] = alloc[i]
            index[v] = t
            # get the utility for v if it do task t with this allocation for the other vehicles
            utility = utilities[tuple(index)][v]
            expected+= utility * proba # add proba time the utility of v to the expectation
        expectations.append(expected)
    return expectations

def getNashProduct(utilities, allocation):
    """ Compute the nash social welfare criteria of an allocation

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)

    Returns :
        Int
        The nash product welfare of the allocation
        (Utilities are supposed to be expressed as int)

    """

    nsw = 1
    for u in utilities[tuple(allocation)]:
        nsw *= u

    return nsw

def getSumUt(utilities, allocation):
    """ Compute the sum of the utilities of agents generated by an allocation

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)

    Returns :
        Int
        The sum of utilities generated by the allocation
        (Utilities are supposed to be expressed as int)

    """

    sumUt = 0
    for u in utilities[tuple(allocation)]:
        sumUt += u

    return sumUt

def getEgalitarienSW(utilities, allocation):
    """ Compute the egalitarian social welfare measure of agents generated by an allocation

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)

    Returns :
        Int
        The egalitarian social welfare measure generated by the allocation
        (Utilities are supposed to be expressed as int)

    """

    egalitarianSW = utilities[tuple(allocation)][0]

    for u in utilities[tuple(allocation)]:
        if u < egalitarianSW:
            egalitarianSW = u

    return egalitarianSW

def getProportionality(utilities, allocation, vehicles):
    """ Compute if an allocation satisfies the proportionate criteria

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)
        vehicle : List(int) the list of vehicle ids

    Returns :
        Bool
        If an allocation is proportionate (True) or not (False)
        (Utilities are supposed to be expressed as int)

    """
    pfs = getSumUt(utilities, allocation)/len(vehicles)

    for u in utilities[tuple(allocation)]:
        if u < pfs:
            return False

    return True

def computeEnvies(utilities, allocation, vehicles):
    """ Compute the envy of an agent according to its allocation and the ones of others agents

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)
        vehicle : List(int) the list of vehicle ids

    Returns :
        Matrix(Int)
        The envy matrix of dimension nb_vehicles*nb_vehicles

    """

    nb_agents = len(vehicles)
    envies = np.zeros((nb_agents,nb_agents), dtype=int)

    for i in range(nb_agents):
        for j in range(nb_agents):
            if i != j:
                temp_alloc = replaceAlloc(allocation, i, allocation[j])
                envies[i,j] = utilities[tuple(temp_alloc)][i] - utilities[tuple(allocation)][i]

    return envies

def getMaxEnvy(utilities, allocation, vehicles):
    """ compute the maximum value of envy of an allocation

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)
        vehicle : List(int) the list of vehicle ids

    Returns :
        Int
        The maximum envy value
        (Utilities are supposed to be expressed as int)

    """
    envies = computeEnvies(utilities,allocation, vehicles)

    nb_agents = len(vehicles)
    max_envy = 0

    for i in range(nb_agents):
        for j in range(nb_agents):
            if envies[i,j] > max_envy:
                max_envy = envies[i,j]

    return max_envy

def getEnvy(utilities, allocation, vehicles):
    """ Test if an allocation is envy-free or not

    Parameters :
        utilities : Matrix(int) the utility matrix of dimension nb_tasks^nb_vehicles * nb_vehicles
        allocation : List(int) the list of tasks allocades to each vehicle (in order)
        vehicle : List(int) the list of vehicle ids

    Returns :
        Bool
        If an allocation is EF (True) or not (False)
        (Utilities are supposed to be expressed as int)

    """
    max_envy = getMaxEnvy(utilities, allocation, vehicles)

    if max_envy > 0:
        return False

    return True

def getRandomUt(nb_vehicles, nb_tasks, ut_range):
    """ Compute the utility matrix with random value in utility range given and an null task

    Parameters :
        nb_vehicles : int, the number of vehicles
        nb_tasks : int, the number of tasks
        ut_range : Tuple(int) the range of values that utility can take

    Returns :
        Matrix(Int)
        The utility matrix produced

    """
    min_ut, max_ut = ut_range

    shapes = getShape(nb_vehicles,nb_tasks+1)

    utilities = np.random.randint(min_ut,max_ut,shapes)

    alloc_dim = np.zeros([nb_tasks+1]*(nb_vehicles))
    allAlloc = [x for x,_ in np.ndenumerate(alloc_dim)]

    for a in allAlloc:
        for i in range(utilities[a].size):
            if a[i] == 0:
                utilities[a][i] = 0

    return utilities
